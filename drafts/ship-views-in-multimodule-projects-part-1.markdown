---
title: "Ship Views in multi-module projects"
description: "It's a great idea to ship administrative Views with your custom module for handling CRUD interfaces. But this can get tricky to manage when your project consists of multiple, optional modules, that must have an impact on these interfaces. Here's how to solve this issue."
layout: post
favorite: false
tags:
- Wisdom
- Drupal
---

Maybe you've worked on a module *suite* before, a project that comes with multiple modules and optional sub-modules. Prominent examples are [Drupal Commerce](https://www.drupal.org/project/commerce) or [Opigno](https://www.drupal.org/project/opigno). These 2 example projects ship with [Views](https://www.drupal.org/project/views) for listing content, combining it with [VBO](https://www.drupal.org/project/views_bulk_operations) to generate complex CRUD interfaces.

Now here's a scenario that I've experienced a few times. Imagine we have a module called <abbr title="Talk about being original&hellip;">*Advanced Blog*</abbr>. This enables [a custom content type](/lore/2015/05/01/content-type-strategies-part-2-in-code/), and comes with a page for listing and managing *Blog posts*. This page will have a table with title, updated date, author, etc, plus checkboxes for each line, so an administrator can select one or more posts and perform some action. So far, so good. Views and VBO will greatly help generating such a page. Now, imagine our module comes with a sub-module, called *Advanced Blog Statistics*. This module will gather statistics on each blog post. Furthermore, we want to show some of these statistics on the aforementioned page. Inside each row of the table, we will add a small statistics summary, plus a link to a page with more information. This is tricky, for several reasons.

*Important note: I'm going to talk about this mainly from a Drupal 7 perspective, as it is slightly more complex. This is why I will keep mentioning Views and VBO. However, in Drupal 8, Views is included in core, as well as much of VBO's functionality. Furthermore, in Drupal 8 it is considered best practice to ship with views for administrative pages.*

### Not using Views (and VBO)

If we weren't using Views and VBO, we would probably code the page by hand, generating a table on the fly. Drupal 7 does this for content and user lists, so why wouldn't you? Well, for one, it's a lot of code. Just look at [`node_admin_nodes()`](https://api.drupal.org/api/drupal/modules!node!node.admin.inc/function/node_admin_nodes/7), and all its related functions. Furthermore, how do you let other modules insert data in there, while allowing for a modular, loosely-coupled architecture? For example, using:

<pre><code class="language-php">
if (module_exists('advanced_blog_stats')) {
  // Add some columns.
}

</code></pre>

would be a bad idea, as we want to decouple module logic as much as possible. The Drupal standard way would be to use `*_alter()` hooks. However, it must be carefully planned, and there's only so much you can do with alter hooks. For example, in Drupal 7's *content* list (generated by [`node_admin_nodes()`](https://api.drupal.org/api/drupal/modules!node!node.admin.inc/function/node_admin_nodes/7)), you need to alter the *themed* output if you wish to add some information in there. But if 2 modules want to add information to that page, it's almost impossible, as only 1 can alter the themed output reliably.

### Using Views (and VBO)

If we *are* using Views and VBO, we ship a *default view*. This is much easier to maintain, as we simply ship a file with the view definition (PHP code in Drupal 7, YAML in Drupal 8). That's why Drupal 8 ships its administrative pages as views. Once this view is in the system, however, how can another module manipulate it to add information to it, like a new column?

This point is further complicated by the fact that, shipping a default view does not prevent a site administrator from editing it. This is a double-edged sword: you may consider it a *feature* to allow site administrators to customize your admin page, like adding filters, or changing a date format. However, it also means you *give up* on easy-updates. The view which ships with your code is what is known as a *default view*. Once edited by a site administrator, it becomes *overridden*. This means you cannot update it anymore from your module, unless the administrator *reverts* the view back to the default, in which case it is again loaded from your module code.

This is a difficult thing to get right, and there are no perfect solutions to it. It's a matter of making a choice, carefully balancing pros and cons. In my experience, the pros of using Views and VBO outweigh the cons in many situations, so I usually go with the Views + VBO approach. And, it is worth repeating, this *is* the recommended approach in Drupal 8.

## Shipping default views

This one is pretty easy, actually. The best thing to do is create a view through the UI, and export it. No reason to learn Views' View Definition API by heart. I take it you know how to create a view, and how to export it. If not, [Google is your friend](https://www.google.com/search?q=Drupal+create+a+view).

To ship it with your module, you have to copy-paste the exported view definition in a file.

### Drupal 7

First, add the following hook in your module's `.module` file:

<pre><code class="language-php">
/**
 * Implements hook_views_api().
 */
function MYMODULE_views_api() {
  return array(
    'api' => 3,
  );
}

</code></pre>

If this hook is not present, Views will not look for any default views to import.

Next, create a file called `MYMODULE.views_default.inc` at the root of your module directory. In this file, put the following code:

<pre><code class="language-php">
/**
 * Implements hook_views_default_views().
 */
function MYMODULE_views_default_views() {
  $export = array();

  // Copy-paste exported view code here.
  $view = new view();
  $view->name = 'view_machine_name';
  // ...

  $export[$view->name] = $view;

  return $export;
}

</code></pre>

Notice that, thanks to the `$export` array, you can ship multiple default views. Now, upon install (or whenever the caches are cleared), Views will load this information, and generate the appropriate views.

*Side note: if you wish to put the `MYMODULE.views_default.inc` somewhere else, like inside an `includes/` directory, you need to slightly adapt the `hook_views_api()` implementation, like so:*

<pre><code class="language-php">
/**
 * Implements hook_views_api().
 */
function MYMODULE_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'MYMODULE') . '/includes',
  );
}

</code></pre>

### Drupal 8

Drupal 8 is much easier, as Views is now in core and uses the Configuration API. Export the view, which will give you some YAML code. Make sure you strip the UUID line! Then, create a YAML file in the following directory inside your module:

    MYMODULE/config/install/views.view.VIEW_MACHINE_NAME.yml

[See this post for more information.](http://subhojit777.in/create-views-programatically-drupal8/)